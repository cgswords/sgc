#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/queue.h>
#include <signal.h>
#include <ucontext.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include "collector.h"
#include "printer.h"
#include "tags.h"
#include "stack.h"

node* scan_stack(ptr* head, ptr* base, node* live_set) {
  printf("\nStack Scan from %p to %p\n", (void*)head, (void*)base); 
 
  while (base < head) {
    ptr value = *head;
    
    print_stack_entry(stdout, head);
  
    if (TAG(value, mask_pair) == tag_pair ||  
        TAG(value, mask_vector) == tag_vector ||  
        TAG(value, mask_procedure) == tag_procedure) {
      live_set = push(live_set, head);
      printf("  -- Added to the live set!\n");
    }
 
    head--;
  }

  return live_set;
}

long inBounds (ptr *base, long size, ptr addr) {
  if (((long) base) < ((long) addr) && 
      ((long) addr) < ((long) base + size)) return 1;
  return 0;
}

int constant(ptr val) {
  if (val == _contmark || 
      val == _true || val == _false || 
      val == _nil || val == _void ||
      TAG(val, mask_fixnum) == tag_fixnum) {
    return 1;
  }
  return 0;
}

void gcprint(char *name, ptr *loc, ptr *next, ptr val) {
    printf("| %-10s | %16p | %16p | %16p |\n", name, loc, next, val);
}
void gcprintsingle(char *name, void * val) {
    printf("| %-10s |                                       %16p |\n", name, val);
}

ptr *copyCollect (node *live_set, ptr *heap, long heapsize, ptr *tospace) {
  printf("COLLECTING\n");
  ptr *next = tospace;

    printf("+------------+------------------+------------------+------------------+\n");
    printf("| DATA       | FROM             | TO               | VALUE            |\n");
    printf("+------------+------------------+------------------+------------------+\n");
  while (live_set != NULL) {

    ptr *loc = peek(live_set);
    ptr val = *loc;
    fflush(stdout);
    if (!inBounds (tospace, heapsize, val)) {
      switch (TAG(val, mask_pair)){
       case tag_fixnum : {
           gcprint("number", loc, next, val);
           *next = val;
           *loc = *((ptr *)(next));
           next += size_fixnum;
           live_set = pop(live_set);
         }
         break;
       case tag_pair : {
           gcprint("pair", loc, next, val);
           ptr *dest = (ptr *)((long) next | tag_pair);
           CAR(dest) = CAR(loc);
           CDR(dest) = CDR(loc);
           DEREF(val) = (ptr) next; 
           *loc = *dest;
           next += size_pair;
           ptr *adest = &(CAR(dest));
           ptr *ddest = &(CDR(dest));
           live_set = enqueue(enqueue(pop(live_set), adest), ddest);
        }
        break;
      case tag_procedure : {
        gcprint("procedure", loc, next, val);
        int i;
        live_set = pop(live_set);
        ptr code = PROCCODE(val);
        ptr size = UNFIX(PROCLENGTH(val));
        ptr *data = PROCDATA(val);
        printf("+------------+------------------+------------------+------------------+\n");
        gcprintsingle(" [code] ", code);
        gcprintsingle(" [size] ", size);

        memcpy(next, loc, (size+2)*word_size);

        /* *loc = (ptr)((long)next + tag_procedure); */
        *loc = (((long)next) + tag_procedure);
        /* val = next; */

        for(i = 0; i < size; i++) {
          gcprintsingle(" [data] ", *(data + i));
          /* Special case for self-reference */
          if (*(data + i) == val) {
            *(data + i) = *loc;
          } else if (!constant(*(data + i)) && 
                     !inBounds(tospace, heapsize, *(data+i))) {
            gcprintsingle(" >enqueue ", *(data+i));
            live_set = enqueue(live_set, (data+i));
          }
        }

        next += size + 2;
        printf("+------------+------------------+------------------+------------------+\n");
        gcprintsingle(" [NEXT] ", next);
      }
      break;
      case tag_vector : {
        gcprint("vector", loc, next, val);
         long i, n;
         ptr *p, *d;
         
         n = UNFIX(VECTORLENGTH(val));
         p = VECTORDATA(val);
         i = n;
         ptr *dest = (ptr *)((long) next | tag_vector);
         VECTORLENGTH(dest) = FIX(n);
         d = VECTORDATA(dest);
         live_set = pop(live_set);
               
         for(i = 0; i < n; i++) {
           *d = *p;
           live_set = enqueue(live_set , d);
           ++d; ++p;
         }
         next += (n + 1);
       }
       break;
    default:
      printf("TODO handle default case line:%d file:%s", __LINE__, __FILE__);
      exit(EXIT_FAILURE);
      }
    } else {
      if (inBounds(tospace, heapsize, val)) {
        gcprint("procedure", loc, next, val);
        *loc = val;
        live_set = pop(live_set);
      }
    }
    printf("+------------+------------------+------------------+------------------+\n");
  }
  printf("Everything's done; let's return.\n");

  return next;
}

ptr *gc(ptr *stack, ptr *heap, ptr* sp, ptr *hp, 
        long alloc_size, long heapsize, long stacksize, long pagesize) {

  long limit = (heapsize / 8) - (pagesize*8*8*2);
  /* long limit = 0; */

  if (hp < heap + limit) {
    return hp;
  }

  fprintf(stdout, "GC collect called \n\
|\tStack head: %p\tStack base: %p \n\
|\tHeap head: %p\tHeap base: %p \n",
	  (void*) sp, (void*) stack, (void*) hp, (void*) heap);

  node *live_set = NULL;
  live_set = scan_stack(sp, stack, live_set); 

  ptr *tospace = mallocHeap();
  printf("\n");
  printf("+-------------------------------+---------------------------+\n");
  printf("|  From Space: %p \t| To Space: %p  |\n", heap, tospace);
  printf("+-------------------------------+---------------------------+\n");

  ptr *ret = copyCollect (live_set, heap, heapsize, tospace);

  printf("\n");
  print_stack(stdout, sp, stack);
  
  freeHeap();
  setHeap(tospace);

  fprintf(stdout, "GC collect returning \n\
|\tStack head: %p\tStack base: %p \n\
|\tOld Heap head: %p\tOld Heap base: %p\n|\tHeap head: %p\tHeap base: %p \n",
	  (void*) sp, (void*) stack, (void*) hp, heap, ret, (void*) tospace);

  print_stack(stdout, ret, tospace);

  return ret; 
}


